#![allow(dead_code, unused)]
#[macro_use]
use rouille::*;

use std::env;
use std::fs;
use std::str;
use std::result;
use scraper::{ElementRef, Html, Selector};
use serde::{Deserialize, Serialize};
use std::str::FromStr;

#[derive(Default,Serialize, Deserialize)]
struct LoadProfile {
	stat_name: String,
	per_second: f64,
	per_transaction: f64,
}

#[derive(Default,Serialize, Deserialize)]
struct DBInstance {
	db_name: String,
	db_id: u64,
	instance_name: String, 
	instance_num: u8,
	startup_time: String,
	release: String,
	rac: String,
}

#[derive(Default,Serialize, Deserialize)]
struct WaitClasses {
	wait_class: String,
	waits: u64,
	total_wait_time_s: u64,
	avg_wait_ms: f64,
	db_time_pct: f64,
	avg_act_sess: f64,
}

#[derive(Default,Serialize, Deserialize)]
struct HostCPU {
	cpus: u32,
	cores: u32,
	sockets: u8,
	load_avg_begin: f64,
	load_avg_end: f64,
	pct_user: f64,
	pct_system: f64,
	pct_wio: f64,
	pct_idle: f64,
}

#[derive(Default,Serialize, Deserialize)]
struct TimeModelStats {
	stat_name: String,
	time_s: f64,
	pct_dbtime: f64,
}

#[derive(Default,Serialize, Deserialize)]
struct ForegrooundWaitEvents {
	event: String,
	waits: u64,
	total_wait_time_s: u64,
	avg_wait: f64,
	pct_dbtime: f64,
}

#[derive(Default,Serialize, Deserialize)]
struct SQLElapsedTime {
	sql_id: String,
	elapsed_time_s: f64,
	executions: u64,
	elpased_time_exec_s: f64,
	pct_total: f64,
	pct_cpu: f64, 
	pct_io: f64,
	sql_module: String,
}

#[derive(Default,Serialize, Deserialize)]
struct AWR {
	status: String,
	load_profile: Vec<LoadProfile>,
	db_instance_information: DBInstance,
	wait_classes: Vec<WaitClasses>,
	host_cpu: HostCPU,
	time_model_stats: Vec<TimeModelStats>,
	foreground_wait_events: Vec<ForegrooundWaitEvents>,
	sql_elapsed_time: Vec<SQLElapsedTime>,
}

fn sql_elapsed_time(table: ElementRef) -> Vec<SQLElapsedTime> {
	let mut sql_elapsed_time: Vec<SQLElapsedTime> = Vec::new();
	let row_selector = Selector::parse("tr").unwrap();
    let column_selector = Selector::parse("td").unwrap();

	for row in table.select(&row_selector) {
		let columns: Vec<ElementRef> = row.select(&column_selector).collect::<Vec<_>>();
		if columns.len() == 9 {
			let sql_id = columns[6].text().collect::<Vec<_>>();
			let sql_id = sql_id[0].trim().to_string();
			
			let elapsed_time_s = columns[0].text().collect::<Vec<_>>();
			let elapsed_time_s = f64::from_str(&elapsed_time_s[0].trim().replace(",","")).unwrap_or(0.0);

			let executions = columns[1].text().collect::<Vec<_>>();
			let executions = u64::from_str(&executions[0].trim().replace(",","")).unwrap_or(0);
			
			let elpased_time_exec_s = columns[2].text().collect::<Vec<_>>();
			let elpased_time_exec_s = f64::from_str(&elpased_time_exec_s[0].trim().replace(",","")).unwrap_or(0.0);

			let pct_total = columns[3].text().collect::<Vec<_>>();
			let pct_total = f64::from_str(&pct_total[0].trim().replace(",","")).unwrap_or(0.0);

			let pct_cpu = columns[4].text().collect::<Vec<_>>();
			let pct_cpu = f64::from_str(&pct_cpu[0].trim().replace(",","")).unwrap_or(0.0);

			let pct_io = columns[5].text().collect::<Vec<_>>();
			let pct_io = f64::from_str(&pct_io[0].trim().replace(",","")).unwrap_or(0.0);

			let sql_module = columns[7].text().collect::<Vec<_>>();
			let sql_module = sql_module[0].trim().to_string();

			sql_elapsed_time.push(SQLElapsedTime { sql_id, elapsed_time_s, executions, elpased_time_exec_s, pct_total, pct_cpu, pct_io, sql_module })
		
		}
	}

	sql_elapsed_time
}

fn foreground_wait_events(table: ElementRef) -> Vec<ForegrooundWaitEvents> {
	let mut foreground_wait_events: Vec<ForegrooundWaitEvents> = Vec::new();
	let row_selector = Selector::parse("tr").unwrap();
    let column_selector = Selector::parse("td").unwrap();

	for row in table.select(&row_selector) {
		let columns: Vec<ElementRef> = row.select(&column_selector).collect::<Vec<_>>();
		if columns.len() == 7 {
			let event = columns[0].text().collect::<Vec<_>>();
			let event = event[0].trim();

			let waits = columns[1].text().collect::<Vec<_>>();
			let waits = u64::from_str(&waits[0].trim().replace(",","")).unwrap_or(0);

			let total_wait_time_s = columns[3].text().collect::<Vec<_>>();
			let total_wait_time_s = u64::from_str(&total_wait_time_s[0].trim().replace(",","")).unwrap_or(0);

			let avg_wait = columns[4].text().collect::<Vec<_>>();
			let avg_wait = f64::from_str(&avg_wait[0].trim().replace(",","")).unwrap_or(0.0);

			let pct_dbtime = columns[6].text().collect::<Vec<_>>();
			let pct_dbtime = f64::from_str(&pct_dbtime[0].trim().replace(",","")).unwrap_or(0.0);

			foreground_wait_events.push(ForegrooundWaitEvents { event: event.to_string(), waits, total_wait_time_s, avg_wait, pct_dbtime })
			
		}
	}

	foreground_wait_events	
}

fn time_model_stats(table: ElementRef) -> Vec<TimeModelStats> {
	let mut time_model_stats: Vec<TimeModelStats> = Vec::new();
	let row_selector = Selector::parse("tr").unwrap();
    let column_selector = Selector::parse("td").unwrap();

	for row in table.select(&row_selector) {
		let columns: Vec<ElementRef> = row.select(&column_selector).collect::<Vec<_>>();
		if columns.len() == 4 {
			let stat_name = columns[0].text().collect::<Vec<_>>();
			let stat_name = stat_name[0].trim();

			let time_s = columns[1].text().collect::<Vec<_>>();
			let time_s = f64::from_str(&time_s[0].trim().replace(",","")).unwrap_or(0.0);

			let pct_dbtime = columns[2].text().collect::<Vec<_>>();
			let pct_dbtime = f64::from_str(&pct_dbtime[0].trim().replace(",","")).unwrap_or(0.0);

			time_model_stats.push(TimeModelStats {stat_name: stat_name.to_string(), time_s, pct_dbtime })
		}
	}

	time_model_stats
}

fn host_cpu(table: ElementRef) -> HostCPU {
	let mut host_cpu: HostCPU = HostCPU::default();
	let row_selector = Selector::parse("tr").unwrap();
    let column_selector = Selector::parse("td").unwrap();

	for row in table.select(&row_selector) {
            let columns: Vec<ElementRef> = row.select(&column_selector).collect::<Vec<_>>();
            if columns.len() == 9 {
				let cpus = columns[0].text().collect::<Vec<_>>();
				let cpus: u32 = u32::from_str(&cpus[0].trim().replace(",","")).unwrap_or(0);

				let cores = columns[1].text().collect::<Vec<_>>();
				let cores: u32 = u32::from_str(&cores[0].trim().replace(",","")).unwrap_or(0);

				let sockets = columns[2].text().collect::<Vec<_>>();
				let sockets: u8 = u8::from_str(&sockets[0].trim().replace(",","")).unwrap_or(0);

				let load_avg_begin =  columns[3].text().collect::<Vec<_>>();
				let load_avg_begin: f64 = f64::from_str(&load_avg_begin[0].trim().replace(",","")).unwrap_or(0.0);

				let load_avg_end = columns[4].text().collect::<Vec<_>>();
				let load_avg_end: f64 = f64::from_str(&load_avg_end[0].trim().replace(",","")).unwrap_or(0.0);

				let pct_user = columns[5].text().collect::<Vec<_>>();
				let pct_user: f64 = f64::from_str(&pct_user[0].trim().replace(",","")).unwrap_or(0.0);

				let pct_system = columns[6].text().collect::<Vec<_>>();
				let pct_system: f64 = f64::from_str(&pct_system[0].trim().replace(",","")).unwrap_or(0.0);

				let pct_wio = columns[7].text().collect::<Vec<_>>();
				let pct_wio: f64 = f64::from_str(&pct_wio[0].trim().replace(",","")).unwrap_or(0.0); 

				let pct_idle = columns[8].text().collect::<Vec<_>>();
				let pct_idle: f64 = f64::from_str(&pct_idle[0].trim().replace(",","")).unwrap_or(0.0); 

				host_cpu = HostCPU{cpus, cores, sockets, load_avg_begin, load_avg_end, pct_user, pct_system, pct_wio, pct_idle};
		}
	}

	host_cpu
}

fn wait_classes(table: ElementRef) -> Vec<WaitClasses> {
	let mut wait_classes: Vec<WaitClasses> = Vec::new();
	let row_selector = Selector::parse("tr").unwrap();
        let column_selector = Selector::parse("td").unwrap();

	for row in table.select(&row_selector) {
            let columns = row.select(&column_selector).collect::<Vec<_>>();
            if columns.len() == 6 {
				let wait_class = columns[0].text().collect::<Vec<_>>();
				let wait_class = wait_class[0].trim();

				let waits = columns[1].text().collect::<Vec<_>>();
				let waits = u64::from_str(&waits[0].trim().replace(",","")).unwrap_or(0);

				let total_wait_time = columns[2].text().collect::<Vec<_>>();
				let total_wait_time = u64::from_str(&total_wait_time[0].trim().replace(",","")).unwrap_or(0);

				let avg_wait_ms = columns[3].text().collect::<Vec<_>>();
				let avg_wait_ms = f64::from_str(&avg_wait_ms[0].trim().replace(",","")).unwrap_or(0.0);

				let db_time_pct = columns[4].text().collect::<Vec<_>>();
				let db_time_pct = f64::from_str(&db_time_pct[0].trim().replace(",","")).unwrap_or(0.0);

				let avg_act_sess = columns[5].text().collect::<Vec<_>>();
				let avg_act_sess = f64::from_str(&avg_act_sess[0].trim().replace(",","")).unwrap_or(0.0);

				wait_classes.push(WaitClasses {wait_class: wait_class.to_string(),
								waits: waits,
								total_wait_time_s: total_wait_time,
								avg_wait_ms: avg_wait_ms,
								db_time_pct: db_time_pct,
								avg_act_sess: avg_act_sess
								});
			}
		}
	wait_classes
}

fn instance_info(table: ElementRef) -> DBInstance {
	let mut dbi = DBInstance::default();
	let row_selector = Selector::parse("tr").unwrap();
    	let column_selector = Selector::parse("td").unwrap();

	for row in table.select(&row_selector) {
        	let columns = row.select(&column_selector).collect::<Vec<_>>();
        	if columns.len() == 7 {
			let dbname = columns[0].text().collect::<Vec<_>>();
			let dbname = dbname[0].trim();

			let dbid = columns[1].text().collect::<Vec<_>>();
			let dbid = u64::from_str(&dbid[0].trim()).unwrap_or(0);

			let iname = columns[2].text().collect::<Vec<_>>();
			let iname = iname[0].trim();

			let inum = columns[3].text().collect::<Vec<_>>();
			let inum = u8::from_str(&inum[0].trim()).unwrap_or(0);

			let startup_time = columns[4].text().collect::<Vec<_>>();
			let startup_time = startup_time[0].trim();

			let release = columns[5].text().collect::<Vec<_>>();
			let release = release[0].trim();

			let israc = columns[6].text().collect::<Vec<_>>();
			let israc = israc[0].trim();

			dbi = DBInstance{db_name: dbname.to_string(), 
					 db_id: dbid, 
					 instance_name: iname.to_string(), 
					 instance_num: inum, 
                                         startup_time: startup_time.to_string(), 
				         release: release.to_string(), 
                                         rac: israc.to_string()};
		}
	}
	dbi
}

fn load_profile(table: ElementRef) -> Vec<LoadProfile>{
    let row_selector = Selector::parse("tr").unwrap();
    let column_selector = Selector::parse("td").unwrap();
    let mut lp: Vec<LoadProfile> = Vec::new();
    for row in table.select(&row_selector) {
	let columns = row.select(&column_selector).collect::<Vec<_>>();
	if columns.len() == 5 {
		let statname = columns[0].text().collect::<Vec<_>>();
		let statname = statname[0].trim();
		
		let per_second = columns[1].text().collect::<Vec<_>>();
		let per_second = f64::from_str(&per_second[0].trim().replace(",","")).unwrap_or(0.0);

		let per_transaction = columns[2].text().collect::<Vec<_>>();
		let per_transaction = f64::from_str(&per_transaction[0].trim().replace(",", "")).unwrap_or(0.0);

		lp.push(LoadProfile{stat_name: statname.to_string(), per_second: per_second, per_transaction: per_transaction});
	}
    }
    lp
}

fn parse_awr_report(fname: &str) -> Result<String, std::io::Error> {
    let html_file = fs::read_to_string(fname);
	let html = match html_file {
		Ok(f) => f,
		Err(e) => return Err(e),
	};

    let doc = Html::parse_document(&html);
    let table_selector = Selector::parse("table").unwrap();
    let row_selector = Selector::parse("tr").unwrap();
    let column_selector = Selector::parse("td").unwrap();

    let mut awr: AWR = AWR::default();

    for element in doc.select(&table_selector) {
        if element.value().attr("summary").unwrap() == "This table displays load profile" {
			awr.load_profile = load_profile(element);
        } else if element.value().attr("summary").unwrap() == "This table displays database instance information" {
			awr.db_instance_information = instance_info(element);
		} else if element.value().attr("summary").unwrap() == "This table displays wait class statistics ordered by total wait time" {
			awr.wait_classes = wait_classes(element);
		} else if element.value().attr("summary").unwrap() == "This table displays system load statistics" {
			awr.host_cpu = host_cpu(element);
		} else if element.value().attr("summary").unwrap() == "This table displays different time model statistics. For each statistic, time and % of DB time are displayed" {
			awr.time_model_stats = time_model_stats(element);
		} else if element.value().attr("summary").unwrap() == "This table displays Foreground Wait Events and their wait statistics" {
			awr.foreground_wait_events = foreground_wait_events(element);
		} else if element.value().attr("summary").unwrap() == "This table displays top SQL by elapsed time" {
			awr.sql_elapsed_time = sql_elapsed_time(element);
		}
    }
	awr.status = "OK".to_string();
    let awr_doc: String = serde_json::to_string_pretty(&awr).unwrap();
	Ok(awr_doc)
}

fn main() {
    /*let args = env::args().collect::<Vec<String>>();
    parse_awr_report(&args[1]);*/
	println!("Now listening on localhost:8000");

	rouille::start_server("localhost:8000", move |request| {
		router!(request,
            (GET) (/) => {
				rouille::Response::text("hello world")
			},
			(GET) (/parse/{fname: String}) => {
				let awr_doc = match parse_awr_report(&fname) {
					Ok(awr) => awr,
					Err(e) => format!("{{\"status\": \"ERROR\", \"msg\": \"Problem with a file {} - error: {}\"}}", &fname, e),
				};
				rouille::Response::text(awr_doc)
			},
			(POST) (/ostask) => {
				let body: String = try_or_400!(rouille::input::json_input(request));
				rouille::Response::text(body)
			},
			_ => rouille::Response::empty_404()
		)
	});

}
